import argparse
import os
import platform
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import List, Optional, Union

# Configuration paths
PROJECT_DIR = Path(__file__).resolve().parent
BUILD_DIR = PROJECT_DIR / "build"
BUILD_DIR.mkdir(parents=True, exist_ok=True)
MAIN_TEX_FILE = PROJECT_DIR / "main.tex"


def execute_cmd(cmd: Union[str, List[str]], raise_error: bool = True, cwd: Optional[Path] = None) -> int:
    """
    Execute command using subprocess.Popen with real-time output printing.
    Enhanced for better encoding handling and process management.
    """
    is_windows = platform.system().lower() == "windows"
    shell_arg = True

    # Windows usually uses gbk/cp936, Linux/Mac uses utf-8
    encoding = "gbk" if is_windows else "utf-8"

    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    print(f"\n[CMD] Executing: {cmd_str}")

    env = os.environ.copy()
    captured_logs = []

    try:
        with subprocess.Popen(
            cmd,
            shell=shell_arg,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,  # Merge stderr into stdout
            cwd=str(cwd) if cwd else None,
            env=env,
        ) as p:
            if p.stdout:
                # Read output line by line iteratively to prevent buffer blocking
                for line in iter(p.stdout.readline, b""):
                    try:
                        line_str = line.decode(encoding, errors="replace").rstrip()
                    except Exception:
                        line_str = line.decode("utf-8", errors="replace").rstrip()

                    if line_str:
                        print(line_str)
                        captured_logs.append(line_str)

            p.wait()
            exitcode = p.returncode

            if exitcode != 0:
                error_msg = f"\nCommand failed with exit code {exitcode}.\nCommand: {cmd_str}\n"
                # If failed, print the last 20 lines of log for debugging
                error_msg += "\n--- Last 20 lines of output ---\n"
                error_msg += "\n".join(captured_logs[-20:])

                print("\n" + "!" * 10 + "  EXECUTION FAILED  " + "!" * 10)
                if raise_error:
                    raise subprocess.CalledProcessError(exitcode, cmd, output="\n".join(captured_logs))
                else:
                    return exitcode

    except KeyboardInterrupt:
        print("\n[WARN] Process interrupted by user.")
        return 130

    return 0


def clean_up(target_file: Path):
    """Clean up auxiliary files generated by latexmk."""
    print(f"\n[INFO] Cleaning up auxiliary files for {target_file.name}...")
    cmd = f'latexmk -C -outdir="{str(PROJECT_DIR)}" "{str(target_file)}"'
    execute_cmd(cmd, raise_error=False)

    # Clean up leftover .bbl files
    bbl_file = PROJECT_DIR / f"{target_file.stem}.bbl"
    if bbl_file.exists():
        try:
            bbl_file.unlink()
        except OSError:
            pass

    # Clean up xelatex*.fls files (Specific to this project)
    for fls_file in PROJECT_DIR.glob("xelatex*.fls"):
        try:
            fls_file.unlink()
        except OSError:
            pass


def main(args):
    # 1. Check environment
    if shutil.which("latexmk") is None:
        raise RuntimeError("latexmk is not installed.")

    # 2. Determine entry file and mode
    if args.tex_entry_file:
        tex_entry_file = args.tex_entry_file
        # If file is specified, default to False unless --handout is explicitly set
        is_nsfc_mode = args.handout
    else:
        tex_entry_file = MAIN_TEX_FILE
        # If no file specified, default to main.tex and enable NSFC naming mode
        is_nsfc_mode = True

    if not tex_entry_file.exists():
        raise FileNotFoundError(f"TeX file not found: {tex_entry_file}")

    # 3. Determine output filename
    custom_output_name = None
    if args.output_file_name:
        custom_output_name = args.output_file_name
        if not custom_output_name.lower().endswith(".pdf"):
            custom_output_name += ".pdf"

    # 4. Construct compilation command
    # Using -xelatex as per original script
    job_name = tex_entry_file.stem
    cmd = f'latexmk -xelatex --shell-escape -f -outdir="{str(PROJECT_DIR)}" ' f'-jobname="{job_name}" "{str(tex_entry_file)}"'

    # 5. Execute compilation
    try:
        exitcode = execute_cmd(cmd)
        if exitcode != 0:
            sys.exit(exitcode)
    except subprocess.CalledProcessError:
        if args.gc:
            clean_up(tex_entry_file)
        sys.exit(1)

    # 6. Process generated files
    generated_pdf = PROJECT_DIR / f"{job_name}.pdf"

    if not generated_pdf.exists():
        print("[ERROR] PDF was not generated successfully.")
        sys.exit(1)

    # Determine backup/final file path
    suffix = time.strftime("%Y%m%d-%H%M%S")

    if custom_output_name:
        # Case A: User specified output filename
        backup_pdf_name = custom_output_name
    elif tex_entry_file.stem == MAIN_TEX_FILE.stem and is_nsfc_mode:
        # Case B: Default main.tex and default mode -> NSFC application name
        backup_pdf_name = f"NSFC-申请书-{suffix}.pdf"
    else:
        # Case C: Other cases -> Original filename
        backup_pdf_name = f"{tex_entry_file.stem}.pdf"

    backup_pdf_path = BUILD_DIR / backup_pdf_name

    print(f"\n[INFO] Copying result to: {backup_pdf_path}")
    shutil.copy(generated_pdf, backup_pdf_path)

    # Backup log file
    generated_log = generated_pdf.with_suffix(".log")
    if generated_log.exists():
        shutil.copy(generated_log, backup_pdf_path.with_suffix(".log"))

    # 7. Clean up (Garbage Collection)
    if args.gc:
        clean_up(tex_entry_file)
    else:
        print("\n[INFO] Build files kept. Use --gc to clean up.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Compile LaTeX files for NSFC Application.")

    # First positional argument: Input file (optional)
    parser.add_argument(
        "tex_entry_file", nargs="?", type=Path, default=None, help="The .tex file to compile. Defaults to main.tex."
    )

    # Second positional argument: Output filename (optional)
    parser.add_argument("output_file_name", nargs="?", type=str, default=None, help="Custom output PDF name.")

    parser.add_argument("--handout", action="store_true", help="Force NSFC naming convention even for non-default files.")

    parser.add_argument("--gc", action="store_true", help="Garbage collect (clean) build files after compilation.")

    args = parser.parse_args()

    # Path expansion
    if args.tex_entry_file:
        args.tex_entry_file = args.tex_entry_file.expanduser().resolve()

    try:
        main(args)
    except KeyboardInterrupt:
        print("\n[INFO] Script interrupted.")
        sys.exit(130)
    except Exception as e:
        print(f"\n[ERROR] {e}")
        sys.exit(1)
